{"ast":null,"code":"import Moment from 'react-moment';\nexport async function parse(response) {\n  const resultArr = [];\n  await response[\"data\"].forEach(video => {\n    const clip = video[\"clip\"];\n    const largestImage = clip[\"pictures\"][\"sizes\"].length - 1;\n    resultArr.push({\n      name: clip.name,\n      description: clip.description,\n      uri: clip.uri,\n      videoID: clip.uri.slice(8),\n      //this may be redundant as I already have the uri, but for ease of access and for unique map key, its here\n      created: clip.created_time,\n      featured: video.is_featured,\n      URLformat: \"https://vimeo.com/\" + video[\"clip\"].uri.slice(8),\n      language: clip.language,\n      duration: clip.duration,\n      plays: clip[\"stats\"].plays,\n      comments: clip[\"metadata\"][\"connections\"][\"comments\"].total,\n      user: clip[\"user\"].name,\n      userLink: clip[\"user\"].link,\n      pictures: clip[\"pictures\"][\"sizes\"][largestImage].link\n    });\n  });\n  return resultArr;\n} // sorting logic \n\nexport function sort(results, sortType) {\n  if (sortType === \"Relevance\") {}\n\n  if (sortType === \"Popularity\") {\n    results.sort((a, b) => {\n      return a.plays > b.plays ? -1 : 1; //had to use plays because favorites was not provided in example data \n    });\n  }\n\n  if (sortType === \"TitleAZ\") {\n    results.sort((a, b) => {\n      return a.name.toLowerCase() > b.name.toLowerCase() ? 1 : -1;\n    });\n  }\n\n  if (sortType === \"TitleZA\") {\n    results.sort((a, b) => {\n      return a.name.toLowerCase() > b.name.toLowerCase() ? -1 : 1;\n    });\n  }\n\n  if (sortType === \"Longest\") {\n    results.sort((a, b) => {\n      return a.duration > b.duration ? -1 : 1;\n    });\n  }\n\n  if (sortType === \"Shortest\") {\n    results.sort((a, b) => {\n      return a.duration > b.duration ? 1 : -1;\n    });\n  }\n\n  if (sortType === \"Newest\") {\n    results.sort((a, b) => {\n      return a.created > b.created ? -1 : 1;\n    });\n  }\n\n  if (sortType === \"Oldest\") {\n    results.sort((a, b) => {\n      return a.created > b.created ? 1 : -1;\n    });\n  }\n\n  if (sortType === \"UserAZ\") {\n    results.sort((a, b) => {\n      return a.user.toLowerCase() > b.user.toLowerCase() ? 1 : -1;\n    });\n  }\n\n  if (sortType === \"UserZA\") {\n    results.sort((a, b) => {\n      return a.user.toLowerCase() > b.user.toLowerCase() ? -1 : 1;\n    });\n  }\n\n  return results;\n} // export function sort(results, sortType) {\n//     const table = {\n//         Popularity: results.sort((a,b) => { return (a.plays > b.plays) ? 1 : -1 }),\n//         TitleAZ: results.sort((a,b) => { return (a.name.toLowerCase() > b.name.toLowerCase()) ? 1 : -1 }),\n//         TitleZA: results.sort((a,b) => { return (a.name.toLowerCase() > b.name.toLowerCase()) ? -1 : 1 }),\n//         Longest: results.sort((a,b) => { return (a.duration > b.duration) ? -1 : 1 }),\n//         Shortest: results.sort((a,b) => { return (a.duration > b.duration) ? 1 : -1 }),\n//         Newest: results.sort((a,b) => { return (a.created > b.created) ? -1 : 1 }),\n//         Oldest: results.sort((a,b) => { return (a.created > b.created) ? 1 : -1 }),\n//         UserAZ: results.sort((a,b) => { return (a.user.toLowerCase() > b.user.toLowerCase()) ? 1 : -1 }),\n//         UserZA: results.sort((a,b) => { return (a.user.toLowerCase() > b.user.toLowerCase()) ? -1 : 1 })\n//     }\n//     return table[sortType]\n// }\n\nexport function filter(results, dateFilter, durationFilter, featuredFilter) {\n  const filterDate = (currentResults, currentFilter) => {\n    const rightNow = new Date();\n\n    if (currentFilter === \"anyDate\") {\n      return currentResults;\n    } // if(currentFilter === \"365\") {\n    //     return currentResults.filter(result => video.created > )\n    // }\n    // if(currentFilter === \"30\") {\n    //    return currentResults.filter(result => video.created > )\n    // }\n\n\n    if (currentFilter === \"7\") {\n      return currentResults.filter(results => result.created < rightNow - 7);\n    }\n  }; // const filterDuration = (currentResults, currentFilter) => {\n  //     if (currentFilter === \"anyDuration\") {\n  //         return currentResults\n  //     }\n  //     if (currentFilter === \"short\") {\n  //         return currentResults.filter(result => result.duration < 240)\n  //     }\n  //     if (currentFilter === \"med\") {\n  //         return currentResults.filter(result => result.duration > 240 && result.duration < 600)\n  //     }\n  //     if (currentFilter === \"long\") {\n  //         return currentResults.filter(result => result.duration > 600)\n  //     }\n  // }\n  // const filterFeatured = (currentResults, currentFilter) => {\n  //     if(currentFilter === \"anyFeatured\") {\n  //         return currentResults\n  //     } \n  //     if(currentFilter === \"featured\") {\n  //        return currentResults.filter(result => (result.featured))\n  //     }\n  // }\n  // return filterFeatured(filterDuration(results, durationFilter), featuredFilter)\n\n\n  return results, dateFilter;\n} // the function below could be written much better / dynamically, \n// but for sake of time it's hard coded and only for 1m - 999m, with no thousand support\n\nexport function formatResultNum(response) {\n  const numResults = response.total;\n  const s = numResults.toString();\n\n  if (numResults > 999999 && numResults < 10000000) {\n    return s[0] + \".\" + s[1] + s[2] + \"M\";\n  }\n\n  if (numResults > 9999999 && numResults < 100000000) {\n    return s[0] + s[1] + \".\" + s[2] + s[3] + \"M\";\n  }\n\n  if (numResults > 99999999) {\n    return s[0] + s[1] + s[2] + \".\" + s[3] + s[4] + \"M\";\n  } else {\n    return s;\n  }\n}\nexport function formatTime(seconds) {\n  if (seconds < 0 || isNaN(seconds)) return null;\n  const duration = new Date(null);\n  duration.setSeconds(seconds);\n  const result = duration.toISOString().substr(11, 8);\n  return seconds >= 3600 ? result : result.slice(3);\n}","map":{"version":3,"sources":["/Users/jaredricardo/Desktop/frontend/serp/src/functions.js"],"names":["Moment","parse","response","resultArr","forEach","video","clip","largestImage","length","push","name","description","uri","videoID","slice","created","created_time","featured","is_featured","URLformat","language","duration","plays","comments","total","user","userLink","link","pictures","sort","results","sortType","a","b","toLowerCase","filter","dateFilter","durationFilter","featuredFilter","filterDate","currentResults","currentFilter","rightNow","Date","result","formatResultNum","numResults","s","toString","formatTime","seconds","isNaN","setSeconds","toISOString","substr"],"mappings":"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","sourcesContent":["import Moment from 'react-moment'\n\nexport async function parse(response){\n\n    const resultArr = []\n\n    await response[\"data\"].forEach((video) => {\n\n        const clip = video[\"clip\"] \n        const largestImage = clip[\"pictures\"][\"sizes\"].length - 1\n\n        resultArr.push({\n            name: clip.name,\n            description: clip.description,\n            uri: clip.uri,\n            videoID: clip.uri.slice(8), //this may be redundant as I already have the uri, but for ease of access and for unique map key, its here\n            created: clip.created_time,\n            featured: video.is_featured,\n            URLformat: \"https://vimeo.com/\" + video[\"clip\"].uri.slice(8),\n            language: clip.language,\n            duration: clip.duration, \n            plays: clip[\"stats\"].plays,\n            comments: clip[\"metadata\"][\"connections\"][\"comments\"].total,\n            user: clip[\"user\"].name,\n            userLink: clip[\"user\"].link,\n            pictures: clip[\"pictures\"][\"sizes\"][largestImage].link\n        })\n    })\n    return resultArr\n}   \n\n// sorting logic \n\nexport function sort(results, sortType) {\n    \n    if(sortType === \"Relevance\"){\n\n    } \n    \n    if(sortType === \"Popularity\"){\n        results.sort((a,b) => { \n            return (a.plays > b.plays) ? -1 : 1   //had to use plays because favorites was not provided in example data \n        })\n    } \n    if(sortType === \"TitleAZ\"){\n        results.sort((a,b) => { \n            return (a.name.toLowerCase() > b.name.toLowerCase()) ? 1 : -1\n        })\n    } \n    if(sortType === \"TitleZA\"){\n        results.sort((a,b) => { \n            return (a.name.toLowerCase() > b.name.toLowerCase()) ? -1 : 1\n        })\n    } \n    if(sortType === \"Longest\"){\n        results.sort((a,b) => { \n            return (a.duration > b.duration) ? -1 : 1\n        })\n    } \n    if(sortType === \"Shortest\"){\n        results.sort((a,b) => { \n            return (a.duration > b.duration) ? 1 : -1\n        })\n    } \n    if(sortType === \"Newest\"){\n        results.sort((a,b) => { \n            return (a.created > b.created) ? -1 : 1\n        })\n    } \n    if(sortType === \"Oldest\"){\n        results.sort((a,b) => { \n            return (a.created > b.created) ? 1 : -1\n        })\n    } \n    if(sortType === \"UserAZ\"){\n        results.sort((a,b) => { \n            return (a.user.toLowerCase() > b.user.toLowerCase()) ? 1 : -1\n        })\n    } \n    if(sortType === \"UserZA\"){\n        results.sort((a,b) => { \n            return (a.user.toLowerCase() > b.user.toLowerCase()) ? -1 : 1\n        })\n    } \n    return results\n}\n\n// export function sort(results, sortType) {\n//     const table = {\n//         Popularity: results.sort((a,b) => { return (a.plays > b.plays) ? 1 : -1 }),\n//         TitleAZ: results.sort((a,b) => { return (a.name.toLowerCase() > b.name.toLowerCase()) ? 1 : -1 }),\n//         TitleZA: results.sort((a,b) => { return (a.name.toLowerCase() > b.name.toLowerCase()) ? -1 : 1 }),\n//         Longest: results.sort((a,b) => { return (a.duration > b.duration) ? -1 : 1 }),\n//         Shortest: results.sort((a,b) => { return (a.duration > b.duration) ? 1 : -1 }),\n//         Newest: results.sort((a,b) => { return (a.created > b.created) ? -1 : 1 }),\n//         Oldest: results.sort((a,b) => { return (a.created > b.created) ? 1 : -1 }),\n//         UserAZ: results.sort((a,b) => { return (a.user.toLowerCase() > b.user.toLowerCase()) ? 1 : -1 }),\n//         UserZA: results.sort((a,b) => { return (a.user.toLowerCase() > b.user.toLowerCase()) ? -1 : 1 })\n//     }\n//     return table[sortType]\n// }\n\nexport function filter(results, dateFilter, durationFilter, featuredFilter){\n\n    const filterDate = (currentResults, currentFilter) => {\n        const rightNow = new Date()\n\n        if(currentFilter === \"anyDate\") {\n            return currentResults\n        }\n        // if(currentFilter === \"365\") {\n        //     return currentResults.filter(result => video.created > )\n        // }\n        // if(currentFilter === \"30\") {\n        //    return currentResults.filter(result => video.created > )\n        // }\n        if(currentFilter === \"7\") {\n           return currentResults.filter(results => result.created < rightNow - 7)\n        }\n    }\n\n    // const filterDuration = (currentResults, currentFilter) => {\n    //     if (currentFilter === \"anyDuration\") {\n    //         return currentResults\n    //     }\n    //     if (currentFilter === \"short\") {\n    //         return currentResults.filter(result => result.duration < 240)\n    //     }\n    //     if (currentFilter === \"med\") {\n    //         return currentResults.filter(result => result.duration > 240 && result.duration < 600)\n    //     }\n    //     if (currentFilter === \"long\") {\n    //         return currentResults.filter(result => result.duration > 600)\n    //     }\n    // }\n\n    // const filterFeatured = (currentResults, currentFilter) => {\n    //     if(currentFilter === \"anyFeatured\") {\n    //         return currentResults\n    //     } \n    //     if(currentFilter === \"featured\") {\n    //        return currentResults.filter(result => (result.featured))\n    //     }\n    // }\n\n    // return filterFeatured(filterDuration(results, durationFilter), featuredFilter)\n\n    return (results, dateFilter)\n\n}\n\n// the function below could be written much better / dynamically, \n// but for sake of time it's hard coded and only for 1m - 999m, with no thousand support\n\nexport function formatResultNum(response) {\n    const numResults = response.total\n    const s = numResults.toString()\n    if (numResults > 999999 && numResults < 10000000 ) {\n        return s[0] + \".\" + s[1] + s[2] + \"M\"\n    } \n    if (numResults > 9999999 && numResults < 100000000) {\n        return s[0] + s[1] + \".\" + s[2] + s[3] + \"M\"\n    }\n    if (numResults > 99999999) {\n        return s[0] + s[1] + s[2] + \".\" + s[3] + s[4] + \"M\"\n    } else {\n        return s\n    }\n}\n\nexport function formatTime (seconds) {\n    if(seconds < 0 || isNaN(seconds)) return null\n    const duration = new Date(null)\n    duration.setSeconds(seconds)\n    const result = duration.toISOString().substr(11, 8)\n    return seconds >= 3600  ? result : result.slice(3)\n}"]},"metadata":{},"sourceType":"module"}