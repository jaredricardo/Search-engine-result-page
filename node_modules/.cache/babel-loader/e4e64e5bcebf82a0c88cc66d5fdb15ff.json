{"ast":null,"code":"import animationData from './data/animation.json';\nimport travelData from './data/travel.json';\nimport exampleData from './data/example.json';\nconst table = {\n  \"animation\": animationData,\n  \"travel\": travelData,\n  \"example\": exampleData\n};\nexport function fuzzySearch(data, string) {\n  const resultArr = [];\n  data[\"data\"].forEach(video => {\n    const clip = video[\"clip\"];\n    const largestImage = clip[\"pictures\"][\"sizes\"].length - 1;\n    resultArr.push({\n      name: clip.name,\n      description: clip.description,\n      uri: clip.uri,\n      videoID: clip.uri.slice(8),\n      created: clip.created_time,\n      featured: video.is_featured,\n      URLformat: \"https://vimeo.com/\" + video[\"clip\"].uri.slice(8),\n      language: clip.language,\n      duration: clip.duration,\n      plays: clip[\"stats\"].plays,\n      comments: clip[\"metadata\"][\"connections\"][\"comments\"].total,\n      user: clip[\"user\"].name,\n      userLink: clip[\"user\"].link,\n      pictures: clip[\"pictures\"][\"sizes\"][largestImage].link\n    });\n  }); // this is not a fuzzy match, but a simple regex match of the start of the title\n  // let matches = resultArr.filter(video => {\n  //     const regex = new RegExp(`^${string}`, 'gi')\n  //     return video.name.match(regex)\n  // })\n  // if(string.length === 0) {\n  //     matches = []\n  // }\n  // return matches\n\n  let namesArr = [];\n  namesArr.forEach(video => {\n    namesArr.push(video.name);\n  });\n  let matches = namesArr.filter(result => {\n    let lastFound = 0; // last found matching character  \n\n    for (let i = 0; i < string.lengh; i++) {\n      let l = string[i];\n      if (l == ' ') continue; // skips blank spaces\n\n      lastFound = result.indexOf(l, lastFound + 1); //looks for current char, updates position\n\n      if (lastFound == -1) return false; // if nothing found, exclude \n    }\n\n    return true;\n  });\n  console.log(matches);\n}\nexport async function getVideoData(param) {\n  const resultArr = [];\n  if (table[param.toLowerCase()] === undefined) return false;\n  await table[param.toLowerCase()][\"data\"].forEach(video => {\n    const clip = video[\"clip\"];\n    const largestImage = clip[\"pictures\"][\"sizes\"].length - 1; // I felt that re-writing the data in this object array format helped me reason more clearly when mapping\n    // and generally manipulating the data for rendering. I could have simply worked with JSON data as it\n    // came from the example files, but felt that would be overly verbose and opted for a quick reorginization. \n\n    resultArr.push({\n      name: clip.name,\n      description: clip.description,\n      uri: clip.uri,\n      videoID: clip.uri.slice(8),\n      //this may be redundant as I already have the uri, but for ease of access and for unique map key, its here\n      created: clip.created_time,\n      featured: video.is_featured,\n      URLformat: \"https://vimeo.com/\" + video[\"clip\"].uri.slice(8),\n      language: clip.language,\n      duration: clip.duration,\n      plays: clip[\"stats\"].plays,\n      comments: clip[\"metadata\"][\"connections\"][\"comments\"].total,\n      user: clip[\"user\"].name,\n      userLink: clip[\"user\"].link,\n      pictures: clip[\"pictures\"][\"sizes\"][largestImage].link\n    });\n  });\n  return resultArr;\n} // sorting logic \n\nexport function sort(results, sortType) {\n  if (!results) return;\n\n  if (sortType === \"Popularity\") {\n    results.sort((a, b) => {\n      return a.plays > b.plays ? -1 : 1; //had to use plays because favorites was not provided in example data \n    });\n  }\n\n  if (sortType === \"TitleAZ\") {\n    results.sort((a, b) => {\n      return a.name.toLowerCase() > b.name.toLowerCase() ? 1 : -1;\n    });\n  }\n\n  if (sortType === \"TitleZA\") {\n    results.sort((a, b) => {\n      return a.name.toLowerCase() > b.name.toLowerCase() ? -1 : 1;\n    });\n  }\n\n  if (sortType === \"Longest\") {\n    results.sort((a, b) => {\n      return a.duration > b.duration ? -1 : 1;\n    });\n  }\n\n  if (sortType === \"Shortest\") {\n    results.sort((a, b) => {\n      return a.duration > b.duration ? 1 : -1;\n    });\n  }\n\n  if (sortType === \"Newest\") {\n    results.sort((a, b) => {\n      return a.created > b.created ? -1 : 1;\n    });\n  }\n\n  if (sortType === \"Oldest\") {\n    results.sort((a, b) => {\n      return a.created > b.created ? 1 : -1;\n    });\n  }\n\n  if (sortType === \"UserAZ\") {\n    results.sort((a, b) => {\n      return a.user.toLowerCase() > b.user.toLowerCase() ? 1 : -1;\n    });\n  }\n\n  if (sortType === \"UserZA\") {\n    results.sort((a, b) => {\n      return a.user.toLowerCase() > b.user.toLowerCase() ? -1 : 1;\n    });\n  }\n\n  return results;\n} //the code commented out below was a lookup table for the sort function. I wanted to add this \n// for both the sort function and filter function to clean up /condense the code. However, time got away \n// from me and I was running into problems where I hadn't expected. For the sake of time \n// I left the if statements for both functions as is. \n// export function sort(results, sortType) {\n//     const table = {\n//         Popularity: results.sort((a,b) => { return (a.plays > b.plays) ? 1 : -1 }),\n//         TitleAZ: results.sort((a,b) => { return (a.name.toLowerCase() > b.name.toLowerCase()) ? 1 : -1 }),\n//         TitleZA: results.sort((a,b) => { return (a.name.toLowerCase() > b.name.toLowerCase()) ? -1 : 1 }),\n//         Longest: results.sort((a,b) => { return (a.duration > b.duration) ? -1 : 1 }),\n//         Shortest: results.sort((a,b) => { return (a.duration > b.duration) ? 1 : -1 }),\n//         Newest: results.sort((a,b) => { return (a.created > b.created) ? -1 : 1 }),\n//         Oldest: results.sort((a,b) => { return (a.created > b.created) ? 1 : -1 }),\n//         UserAZ: results.sort((a,b) => { return (a.user.toLowerCase() > b.user.toLowerCase()) ? 1 : -1 }),\n//         UserZA: results.sort((a,b) => { return (a.user.toLowerCase() > b.user.toLowerCase()) ? -1 : 1 })\n//     }\n//     return table[sortType]\n// }\n\nexport function filter(results, dateFilter, durationFilter, featuredFilter) {\n  const resultsExist = results.length > 0;\n\n  const filterDate = (currentResults, currentFilter) => {\n    const rightNow = Date.now();\n    const week = 7 * 86400000; //miliseconds in a day \n\n    const month = 30 * 86400000;\n    const year = 365 * 86400000;\n\n    if (currentFilter === \"anyDate\") {\n      return currentResults;\n    }\n\n    if (currentFilter === \"365\" && resultsExist) {\n      return currentResults.filter(result => rightNow - Date.parse(result.created) < year);\n    }\n\n    if (currentFilter === \"30\" && resultsExist) {\n      return currentResults.filter(result => rightNow - Date.parse(result.created) < month);\n    }\n\n    if (currentFilter === \"7\" && resultsExist) {\n      return currentResults.filter(result => rightNow - Date.parse(result.created) < week);\n    }\n  };\n\n  const filterDuration = (currentResults, currentFilter) => {\n    if (currentFilter === \"anyDuration\") {\n      return currentResults;\n    }\n\n    if (currentFilter === \"short\" && resultsExist) {\n      return currentResults.filter(result => result.duration < 240);\n    }\n\n    if (currentFilter === \"med\" && resultsExist) {\n      return currentResults.filter(result => result.duration > 240 && result.duration < 600);\n    }\n\n    if (currentFilter === \"long\" && resultsExist) {\n      return currentResults.filter(result => result.duration > 600);\n    }\n  };\n\n  const filterFeatured = (currentResults, currentFilter) => {\n    if (currentFilter === \"anyFeatured\" && resultsExist) {\n      return currentResults;\n    }\n\n    if (currentFilter === \"featured\" && resultsExist) {\n      return currentResults.filter(result => result.featured);\n    }\n  }; //Initially, I tried to write a filtering function that took the filtering values all at once. This ended up not working,\n  // as the returned results were filtered incorectly when I switched between different / multiple filter types. I realized that my \n  // filter function ALWAYS needed to be fed the same unmutated state, and would I then need to set this new filtered\n  // state as what was rendered (hence the filtered: true / false conditionals in the main componenet) This ensured \n  // that no matter how much I changed the filters or sorting, my original result state stayed in tact and would be\n  // cleanly accesible when I needed. \n\n\n  return filterDate(filterFeatured(filterDuration(results, durationFilter), featuredFilter), dateFilter);\n} // the function below could be written much better / dynamically, \n// but for sake of time it's hard coded and only for 1m - 999m, with no thousand support\n\nexport function formatResultNum(param) {\n  if (table[param.toLowerCase()] === undefined) {\n    return \"0\";\n  } else {\n    const numResults = table[param.toLowerCase()].total;\n    const s = numResults.toString();\n\n    if (numResults > 999999 && numResults < 10000000) {\n      return s[0] + \".\" + s[1] + s[2] + \"M\";\n    }\n\n    if (numResults > 9999999 && numResults < 100000000) {\n      return s[0] + s[1] + \".\" + s[2] + s[3] + \"M\";\n    }\n\n    if (numResults > 99999999) {\n      return s[0] + s[1] + s[2] + \".\" + s[3] + s[4] + \"M\";\n    } else {\n      return s;\n    }\n  }\n}\nexport function formatTime(seconds) {\n  if (seconds < 0 || isNaN(seconds)) return null;\n  const duration = new Date(null);\n  duration.setSeconds(seconds);\n  const result = duration.toISOString().substr(11, 8);\n  return seconds >= 3600 ? result : result.slice(3);\n}","map":{"version":3,"sources":["/Users/jaredricardo/Desktop/serp copy/src/functions.js"],"names":["animationData","travelData","exampleData","table","fuzzySearch","data","string","resultArr","forEach","video","clip","largestImage","length","push","name","description","uri","videoID","slice","created","created_time","featured","is_featured","URLformat","language","duration","plays","comments","total","user","userLink","link","pictures","namesArr","matches","filter","result","lastFound","i","lengh","l","indexOf","console","log","getVideoData","param","toLowerCase","undefined","sort","results","sortType","a","b","dateFilter","durationFilter","featuredFilter","resultsExist","filterDate","currentResults","currentFilter","rightNow","Date","now","week","month","year","parse","filterDuration","filterFeatured","formatResultNum","numResults","s","toString","formatTime","seconds","isNaN","setSeconds","toISOString","substr"],"mappings":"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","sourcesContent":["import animationData from './data/animation.json'\nimport travelData from './data/travel.json'\nimport exampleData from './data/example.json'\n\n\n\nconst table = {\n    \"animation\": animationData,\n    \"travel\": travelData,\n    \"example\": exampleData,  \n}\n\n\nexport function fuzzySearch(data,string) {\n \n    const resultArr = []\n    \n    data[\"data\"].forEach((video) => {\n        \n        const clip = video[\"clip\"] \n        const largestImage = clip[\"pictures\"][\"sizes\"].length - 1\n\n        resultArr.push({\n            name: clip.name,\n            description: clip.description,\n            uri: clip.uri,\n            videoID: clip.uri.slice(8), \n            created: clip.created_time, \n            featured: video.is_featured,\n            URLformat: \"https://vimeo.com/\" + video[\"clip\"].uri.slice(8),\n            language: clip.language,\n            duration: clip.duration, \n            plays: clip[\"stats\"].plays,\n            comments: clip[\"metadata\"][\"connections\"][\"comments\"].total,\n            user: clip[\"user\"].name,\n            userLink: clip[\"user\"].link,\n            pictures: clip[\"pictures\"][\"sizes\"][largestImage].link\n        })\n    })\n\n    // this is not a fuzzy match, but a simple regex match of the start of the title\n\n    // let matches = resultArr.filter(video => {\n    //     const regex = new RegExp(`^${string}`, 'gi')\n    //     return video.name.match(regex)\n    // })\n\n    // if(string.length === 0) {\n    //     matches = []\n    // }\n    // return matches\n    let namesArr = []\n\n    namesArr.forEach((video) => {\n        namesArr.push(video.name)\n    })\n    \n\n    let matches = namesArr.filter((result) => {\n        let lastFound = 0                               // last found matching character  \n        for(let i = 0; i < string.lengh; i++) {\n            let l = string[i]\n            if(l == ' ') continue                      // skips blank spaces\n\n            lastFound = result.indexOf(l, lastFound+1)  //looks for current char, updates position\n            if(lastFound == -1) return false           // if nothing found, exclude \n        }\n        return true\n    })\n    console.log(matches)\n}\n\n\nexport async function getVideoData(param){\n\n    const resultArr = []\n\n    if(table[param.toLowerCase()] === undefined) return false\n    await table[param.toLowerCase()][\"data\"].forEach((video) => {\n        \n        const clip = video[\"clip\"] \n        const largestImage = clip[\"pictures\"][\"sizes\"].length - 1\n\n        // I felt that re-writing the data in this object array format helped me reason more clearly when mapping\n        // and generally manipulating the data for rendering. I could have simply worked with JSON data as it\n        // came from the example files, but felt that would be overly verbose and opted for a quick reorginization. \n\n        resultArr.push({\n            name: clip.name,\n            description: clip.description,\n            uri: clip.uri,\n            videoID: clip.uri.slice(8), //this may be redundant as I already have the uri, but for ease of access and for unique map key, its here\n            created: clip.created_time, \n            featured: video.is_featured,\n            URLformat: \"https://vimeo.com/\" + video[\"clip\"].uri.slice(8),\n            language: clip.language,\n            duration: clip.duration, \n            plays: clip[\"stats\"].plays,\n            comments: clip[\"metadata\"][\"connections\"][\"comments\"].total,\n            user: clip[\"user\"].name,\n            userLink: clip[\"user\"].link,\n            pictures: clip[\"pictures\"][\"sizes\"][largestImage].link\n        })\n    })\n    return resultArr\n}   \n\n// sorting logic \n\nexport function sort(results, sortType) {\n    \n    if(!results) return\n\n    if(sortType === \"Popularity\"){\n        results.sort((a,b) => { \n            return (a.plays > b.plays) ? -1 : 1   //had to use plays because favorites was not provided in example data \n        })\n    } \n    if(sortType === \"TitleAZ\"){\n        results.sort((a,b) => { \n            return (a.name.toLowerCase() > b.name.toLowerCase()) ? 1 : -1\n        })\n    } \n    if(sortType === \"TitleZA\"){\n        results.sort((a,b) => { \n            return (a.name.toLowerCase() > b.name.toLowerCase()) ? -1 : 1\n        })\n    } \n    if(sortType === \"Longest\"){\n        results.sort((a,b) => { \n            return (a.duration > b.duration) ? -1 : 1\n        })\n    } \n    if(sortType === \"Shortest\"){\n        results.sort((a,b) => { \n            return (a.duration > b.duration) ? 1 : -1\n        })\n    } \n    if(sortType === \"Newest\"){\n        results.sort((a,b) => { \n            return (a.created > b.created) ? -1 : 1\n        })\n    } \n    if(sortType === \"Oldest\"){\n        results.sort((a,b) => { \n            return (a.created > b.created) ? 1 : -1\n        })\n    } \n    if(sortType === \"UserAZ\"){\n        results.sort((a,b) => { \n            return (a.user.toLowerCase() > b.user.toLowerCase()) ? 1 : -1\n        })\n    } \n    if(sortType === \"UserZA\"){\n        results.sort((a,b) => { \n            return (a.user.toLowerCase() > b.user.toLowerCase()) ? -1 : 1\n        })\n    } \n    return results\n}\n\n//the code commented out below was a lookup table for the sort function. I wanted to add this \n// for both the sort function and filter function to clean up /condense the code. However, time got away \n// from me and I was running into problems where I hadn't expected. For the sake of time \n// I left the if statements for both functions as is. \n\n// export function sort(results, sortType) {\n//     const table = {\n//         Popularity: results.sort((a,b) => { return (a.plays > b.plays) ? 1 : -1 }),\n//         TitleAZ: results.sort((a,b) => { return (a.name.toLowerCase() > b.name.toLowerCase()) ? 1 : -1 }),\n//         TitleZA: results.sort((a,b) => { return (a.name.toLowerCase() > b.name.toLowerCase()) ? -1 : 1 }),\n//         Longest: results.sort((a,b) => { return (a.duration > b.duration) ? -1 : 1 }),\n//         Shortest: results.sort((a,b) => { return (a.duration > b.duration) ? 1 : -1 }),\n//         Newest: results.sort((a,b) => { return (a.created > b.created) ? -1 : 1 }),\n//         Oldest: results.sort((a,b) => { return (a.created > b.created) ? 1 : -1 }),\n//         UserAZ: results.sort((a,b) => { return (a.user.toLowerCase() > b.user.toLowerCase()) ? 1 : -1 }),\n//         UserZA: results.sort((a,b) => { return (a.user.toLowerCase() > b.user.toLowerCase()) ? -1 : 1 })\n//     }\n//     return table[sortType]\n// }\n\nexport function filter(results, dateFilter, durationFilter, featuredFilter){\n\n    const resultsExist = (results.length > 0) \n\n    const filterDate = (currentResults, currentFilter) => {\n\n        const rightNow = Date.now()\n        const week = 7 * 86400000       //miliseconds in a day \n        const month = 30 * 86400000\n        const year = 365 * 86400000\n\n        if(currentFilter === \"anyDate\") {\n            return currentResults\n        }\n        if(currentFilter === \"365\" && resultsExist) {\n            return currentResults.filter(result => rightNow - Date.parse(result.created) <  year)\n        }\n        if(currentFilter === \"30\" && resultsExist) {\n           return currentResults.filter(result => rightNow - Date.parse(result.created) <  month)\n        }\n        if(currentFilter === \"7\" && resultsExist) {\n          return currentResults.filter(result => rightNow - Date.parse(result.created) <  week)\n        }\n    }\n\n    const filterDuration = (currentResults, currentFilter) => {\n        \n        if (currentFilter === \"anyDuration\") {\n            return currentResults\n        }\n        if (currentFilter === \"short\" && resultsExist) {\n            return currentResults.filter(result => result.duration < 240)\n        }\n        if (currentFilter === \"med\" && resultsExist) {\n            return currentResults.filter(result => result.duration > 240 && result.duration < 600)\n        }\n        if (currentFilter === \"long\" && resultsExist) {\n            return currentResults.filter(result => result.duration > 600)\n        }\n    }\n\n    const filterFeatured = (currentResults, currentFilter) => {\n\n        if(currentFilter === \"anyFeatured\" && resultsExist) {\n            return currentResults\n        } \n        if(currentFilter === \"featured\" && resultsExist) {\n           return currentResults.filter(result => (result.featured))\n        }\n    }\n\n    //Initially, I tried to write a filtering function that took the filtering values all at once. This ended up not working,\n    // as the returned results were filtered incorectly when I switched between different / multiple filter types. I realized that my \n    // filter function ALWAYS needed to be fed the same unmutated state, and would I then need to set this new filtered\n    // state as what was rendered (hence the filtered: true / false conditionals in the main componenet) This ensured \n    // that no matter how much I changed the filters or sorting, my original result state stayed in tact and would be\n    // cleanly accesible when I needed. \n\n    return filterDate(filterFeatured(filterDuration(results, durationFilter), featuredFilter), dateFilter)\n\n}\n\n// the function below could be written much better / dynamically, \n// but for sake of time it's hard coded and only for 1m - 999m, with no thousand support\n\nexport function formatResultNum(param) {\n\n    if(table[param.toLowerCase()] === undefined) {\n        return \"0\"\n    } else {\n        const numResults = table[param.toLowerCase()].total\n        const s = numResults.toString()\n        if (numResults > 999999 && numResults < 10000000 ) {\n            return s[0] + \".\" + s[1] + s[2] + \"M\"\n        } \n        if (numResults > 9999999 && numResults < 100000000) {\n            return s[0] + s[1] + \".\" + s[2] + s[3] + \"M\"\n        }\n        if (numResults > 99999999) {\n            return s[0] + s[1] + s[2] + \".\" + s[3] + s[4] + \"M\"\n        } else {\n            return s\n        }\n    }\n}\n\nexport function formatTime (seconds) {\n    if(seconds < 0 || isNaN(seconds)) return null\n    const duration = new Date(null)\n    duration.setSeconds(seconds)\n    const result = duration.toISOString().substr(11, 8)\n    return seconds >= 3600  ? result : result.slice(3)\n}"]},"metadata":{},"sourceType":"module"}